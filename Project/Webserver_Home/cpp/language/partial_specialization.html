<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<title>partial template specialization - cppreference.com</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">
<link rel="shortcut icon" href="../../../favicon.ico">
<link rel="stylesheet" href="../../../common/ext.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/site_modules.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>

<script src="../../../common/startup_scripts.js"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"cpp/language/partial_specialization","wgTitle":"cpp/language/partial specialization","wgCurRevisionId":91942,"wgArticleId":12828,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages with unreviewed CWG DR marker"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"cpp/language/partial_specialization","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"gadget-ColiruCompiler":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-js:7:ca03345b1e2c4d90a25d968753a73b92 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_partial_specialization skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        <!-- /header -->
        <!-- content -->
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
                <h1 id="firstHeading" class="firstHeading">partial template specialization</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a>‎ | <a href="../language.1.html" title="cpp/language">language</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="t-navbar" style=""><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div><div><table class="t-nv-begin" cellpadding="0" style="line-height:1.1em;">
<tr class="t-nv"><td colspan="5"> <a href="../language.1.html" title="cpp/language"> Language</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../header.html" title="cpp/header"> Standard library headers</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../concept.html" title="cpp/concept"> Concepts</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html" title="cpp/utility"> Utilities library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../string.html" title="cpp/string"> Strings library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../container.html" title="cpp/container"> Containers library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../algorithm.html" title="cpp/algorithm"> Algorithms library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../iterator.html" title="cpp/iterator"> Iterators library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../numeric.html" title="cpp/numeric"> Numerics library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../io.html" title="cpp/io"> Input/output library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../locale.html" title="cpp/locale"> Localizations library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../regex.html" title="cpp/regex"> Regular expressions library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../thread.html" title="cpp/thread"> Thread support library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../filesystem.html" title="cpp/filesystem"> Filesystem library</a> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../experimental.html" title="cpp/experimental"> Technical Specifications</a> </td></tr>
</table></div><div></div></div></div></div><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="../language.1.html" title="cpp/language"> C++ language</a></div><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="templates.html" title="cpp/language/templates"> Templates</a><div class="t-navbar-menu"><div><div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="template_parameters.html" title="cpp/language/template parameters"> parameters and arguments</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="class_template.html" title="cpp/language/class template"> class templates</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="function_template.html" title="cpp/language/function template"> function templates</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="member_template.html" title="cpp/language/member template"> class member templates</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="variable_template.html" title="cpp/language/variable template"> variable templates</a><span class="t-mark-rev t-since-cxx14">(C++14)</span></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="template_argument_deduction.html" title="cpp/language/template argument deduction"> template argument deduction</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="deduction_guide.html" title="cpp/language/class template deduction"> class template deduction</a><span class="t-mark-rev t-since-cxx17">(C++17)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="template_specialization.html" title="cpp/language/template specialization"> explicit (full) specialization</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <strong class="selflink"> partial specialization</strong> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="dependent_name.html" title="cpp/language/dependent name"> dependent names</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="parameter_pack.html" title="cpp/language/parameter pack"> parameter packs</a><span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="sizeof....html" title="cpp/language/sizeof..."><span class="t-lines"><span>sizeof...</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="fold.html" title="cpp/language/fold"> fold-expressions</a><span class="t-mark-rev t-since-cxx17">(C++17)</span></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="sfinae.html" title="cpp/language/sfinae"> SFINAE</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="concepts.html" title="cpp/language/constraints"> Constraints and concepts</a><span class="t-mark-rev t-since-concepts-ts t-mark-ts">(concepts TS)</span> </td></tr>
</table></div>
</div><div></div></div></div></div><div class="t-navbar-sep"> </div></div>
<p>Allows customizing class templates for a given category of template arguments.
</p>
<h3><span class="mw-headline" id="Syntax">Syntax</span></h3>
<table class="t-sdsc-begin">

<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td class="t-sdsc-nopad"> <code><b>template</b></code> <code><b>&lt;</b></code> <span class="t-spar">parameter-list</span> <code><b>&gt;</b></code> <span class="t-spar">class-key</span> <span class="t-spar">class-head-name</span> <code><b>&lt;</b></code> <span class="t-spar">argument-list</span> <code><b>&gt;</b></code> <span class="t-spar">declaration</span>
</td>
<td class="t-sdsc-nopad">
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></table>
<p>where <span class="t-spar">class-head-name</span> identifies the name of a previously declared <a href="class_template.html" title="cpp/language/class template">class template</a>. This declaration must be in the same <a href="namespace.html" title="cpp/language/namespace">namespace</a> or, for <a href="member_template.html" title="cpp/language/member template">member templates</a>, class scope as the primary template definition which it specializes.
</p><p>For example,
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T1, <span class="kw1">class</span> T2, <span class="kw4">int</span> I<span class="sy1">&gt;</span>
<span class="kw1">class</span> A <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>            <span class="co1">// primary template</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw4">int</span> I<span class="sy1">&gt;</span>
<span class="kw1">class</span> A<span class="sy1">&lt;</span>T, T<span class="sy2">*</span>, I<span class="sy1">&gt;</span> <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>  <span class="co1">// #1: partial specialization where T2 is a pointer to T1</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> T2, <span class="kw4">int</span> I<span class="sy1">&gt;</span>
<span class="kw1">class</span> A<span class="sy1">&lt;</span>T<span class="sy2">*</span>, T2, I<span class="sy1">&gt;</span> <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// #2: partial specialization where T1 is a pointer</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">class</span> A<span class="sy1">&lt;</span><span class="kw4">int</span>, T<span class="sy2">*</span>, <span class="nu0">5</span><span class="sy1">&gt;</span> <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// #3: partial specialization where T1 is int, I is 5,</span>
                        <span class="co1">//     and T2 is a pointer</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> X, <span class="kw1">class</span> T, <span class="kw4">int</span> I<span class="sy1">&gt;</span>
<span class="kw1">class</span> A<span class="sy1">&lt;</span>X, T<span class="sy2">*</span>, I<span class="sy1">&gt;</span> <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>   <span class="co1">// #4: partial specialization where T2 is a pointer</span></pre></div></div>
<p>Examples of partial specializations in the standard library include <span class="t-c"><span class="mw-geshi cpp source-cpp"><a href="../memory/unique_ptr.html"><span class="kw731">std::<span class="me2">unique_ptr</span></span></a></span></span>, which has a partial specialization for array types.
</p>
<h3><span class="mw-headline" id="The_argument_list">The argument list</span></h3>
<p>The following restrictions apply to the <span class="t-spar">argument-list</span> of a partial template specialization:
</p>
<div class="t-li1"><span class="t-li">1)</span> The argument list cannot be identical to the non-specialized argument list (it must specialize something)
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T1, <span class="kw1">class</span> T2, <span class="kw4">int</span> I<span class="sy1">&gt;</span> <span class="kw1">class</span> B <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// primary template</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> X, <span class="kw1">class</span> Y, <span class="kw4">int</span> N<span class="sy1">&gt;</span> <span class="kw1">class</span> B<span class="sy1">&lt;</span>X,Y,N<span class="sy1">&gt;</span> <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// error</span></pre></div></div>
 <table class="t-rev-begin">
<tr class="t-rev t-since-cxx14"><td>
<p>Moreover, the specialization has to be more specialized than the primary template
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw4">int</span> N, <span class="kw1">typename</span> T1, <span class="kw1">typename</span>... <span class="me1">Ts</span><span class="sy1">&gt;</span> <span class="kw1">struct</span> B<span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span>... <span class="me1">Ts</span><span class="sy1">&gt;</span> <span class="kw1">struct</span> B<span class="sy1">&lt;</span><span class="nu0">0</span>, Ts...<span class="sy1">&gt;</span> <span class="br0">{</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// Error: not more specialized</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td></tr>
</table></div>
<div class="t-li1"><span class="t-li">2)</span> Default arguments cannot appear in the argument list</div>
<div class="t-li1"><span class="t-li">3)</span> If any argument is a pack expansion, it must be the last argument in the list</div>
<div class="t-li1"><span class="t-li">4)</span> <span class="t-rev-inl t-until-cxx14"><span>Non-type argument expression cannot use the name of the template parameter except when it is exactly the name of the template parameter</span> <span><span class="t-mark-rev t-until-cxx14">(until C++14)</span></span></span><span class="t-rev-inl t-since-cxx14"><span>Non-type argument expressions can use template parameters as long as the parameter appears at least once outside a <a href="template_argument_deduction.html#Non-deduced_contexts" title="cpp/language/template argument deduction">non-deduced context</a></span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw4">int</span> I, <span class="kw4">int</span> J<span class="sy1">&gt;</span> <span class="kw1">struct</span> A <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw4">int</span> I<span class="sy1">&gt;</span> <span class="kw1">struct</span> A<span class="sy1">&lt;</span>I<span class="sy2">+</span><span class="nu0">5</span>, I<span class="sy2">*</span><span class="nu0">2</span><span class="sy1">&gt;</span> <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// error, I is not deducible</span>
 
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw4">int</span> I, <span class="kw4">int</span> J, <span class="kw4">int</span> K<span class="sy1">&gt;</span> <span class="kw1">struct</span> B <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw4">int</span> I<span class="sy1">&gt;</span> <span class="kw1">struct</span> B<span class="sy1">&lt;</span>I, I<span class="sy2">*</span><span class="nu0">2</span>, <span class="nu0">2</span><span class="sy1">&gt;</span> <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>  <span class="co1">// OK: first parameter is deducible</span></pre></div></div></div>
<div class="t-li1"><span class="t-li">5)</span> Non-type template argument cannot specialize a template parameter whose type depends on a parameter of the specialization:
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T, T t<span class="sy1">&gt;</span> <span class="kw1">struct</span> C <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// primary template</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw1">struct</span> C<span class="sy1">&lt;</span>T, <span class="nu0">1</span><span class="sy1">&gt;</span><span class="sy4">;</span> <span class="co1">// error: type of the argument 1 is T,</span>
                                   <span class="co1">// which depends on the parameter T</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw4">int</span> X, <span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>array_ptr<span class="br0">)</span><span class="br0">[</span>X<span class="br0">]</span> <span class="sy1">&gt;</span> <span class="kw1">class</span> B <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// primary template</span>
<span class="kw4">int</span> array<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw4">int</span> X <span class="sy1">&gt;</span> <span class="kw1">class</span> B<span class="sy1">&lt;</span>X,<span class="sy3">&amp;</span>array<span class="sy1">&gt;</span> <span class="br0">{</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// error: type of the argument &amp;array</span>
                             <span class="co1">// is int(*)[X], which depends on the parameter X</span></pre></div></div></div>
<h3><span class="mw-headline" id="Name_lookup">Name lookup</span></h3>
<p>Partial template specializations are not found by name lookup. Only if the primary template is found by name lookup, its partial specializations are considered. In particular, a using declaration that makes a primary template visible, makes partial specializations visible as well:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">namespace</span> N <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T1, <span class="kw1">class</span> T2<span class="sy1">&gt;</span> <span class="kw1">class</span> Z <span class="br0">{</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// primary template</span>
<span class="br0">}</span>
<span class="kw1">using</span> N<span class="sy4">::</span><span class="me2">Z</span><span class="sy4">;</span> <span class="co1">// refers to the primary template</span>
<span class="kw1">namespace</span> N <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw1">class</span> Z<span class="sy1">&lt;</span>T, T<span class="sy2">*</span><span class="sy1">&gt;</span> <span class="br0">{</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// partial specialization</span>
<span class="br0">}</span>
Z<span class="sy1">&lt;</span><span class="kw4">int</span>,<span class="kw4">int</span><span class="sy2">*</span><span class="sy1">&gt;</span> z<span class="sy4">;</span> <span class="co1">// name lookup finds N::Z (the primary template),</span>
               <span class="co1">// the partial specialization with T = int is then used</span></pre></div></div>
<h3><span class="mw-headline" id="Partial_ordering">Partial ordering</span></h3>
<p>When a class template is instantiated, and there are partial specializations available, the compiler has to decide if the primary template is going to be used or one of its partial specializations. 
</p>
<div class="t-li1"><span class="t-li">1)</span> If only one specialization matches the template arguments, that specialization is used</div>
<div class="t-li1"><span class="t-li">2)</span> If more than one specialization matches, partial order rules are used to determine which specialization is more specialized. The most specialized specialization is used, if it is unique (if it is not unique, the program cannot be compiled)</div>
<div class="t-li1"><span class="t-li">3)</span> If no specializations match, the primary template is used
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// given the template A as defined above</span>
A<span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">int</span>, <span class="nu0">1</span><span class="sy1">&gt;</span> a1<span class="sy4">;</span>   <span class="co1">// no specializations match, uses primary template</span>
A<span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">int</span><span class="sy2">*</span>, <span class="nu0">1</span><span class="sy1">&gt;</span> a2<span class="sy4">;</span>  <span class="co1">// uses partial specialization #1 (T=int, I=1)</span>
A<span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">char</span><span class="sy2">*</span>, <span class="nu0">5</span><span class="sy1">&gt;</span> a3<span class="sy4">;</span> <span class="co1">// uses partial specialization #3, (T=char)</span>
A<span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">char</span><span class="sy2">*</span>, <span class="nu0">1</span><span class="sy1">&gt;</span> a4<span class="sy4">;</span> <span class="co1">// uses partial specialization #4, (X=int, T=char, I=1)</span>
A<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy2">*</span>, <span class="kw4">int</span><span class="sy2">*</span>, <span class="nu0">2</span><span class="sy1">&gt;</span> a5<span class="sy4">;</span> <span class="co1">// error: matches #2 (T=int, T2=int*, I=2)</span>
                     <span class="co1">//        matches #4 (X=int*, T=int, I=2)</span>
                     <span class="co1">// neither one is more specialized than the other</span></pre></div></div></div>
<p>Informally "A is more specialized than B" means "A accepts fewer types than B".
</p><p>Formally, to establish more-specialized-than relationship between partial specializations, each is first converted to a fictitious function template as follows:
</p>
<ul><li> the first function template has the same template parameters as the first partial specialization and has just one function parameter, whose type is a class template specialization with all the template arguments from the first partial specialization
</li><li> the second function template has the same template parameters as the second partial specialization and has just one function parameter whose type is a class template specialization with all the template arguments from the second partial specialization.
</li></ul>
<p>The function templates are then ranked as if for <a href="function_template.html#Function_template_overloading" title="cpp/language/function template">function template overloading</a>.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw4">int</span> I, <span class="kw4">int</span> J, <span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw1">struct</span> X <span class="br0">{</span> <span class="br0">}</span><span class="sy4">;</span> <span class="co1">// primary template</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw4">int</span> I, <span class="kw4">int</span> J<span class="sy1">&gt;</span>          <span class="kw1">struct</span> X<span class="sy1">&lt;</span>I, J, <span class="kw4">int</span><span class="sy1">&gt;</span> <span class="br0">{</span>
        <span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">int</span> s <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span> <span class="co1">// partial specialization #1</span>
<span class="co1">// fictitious function template for #1 is</span>
<span class="co1">// template&lt;int I, int J&gt; void f(X&lt;I, J, int&gt;); #A</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw4">int</span> I<span class="sy1">&gt;</span>                 <span class="kw1">struct</span> X<span class="sy1">&lt;</span>I, I, <span class="kw4">int</span><span class="sy1">&gt;</span> <span class="br0">{</span>
        <span class="kw4">static</span> <span class="kw4">const</span> <span class="kw4">int</span> s <span class="sy1">=</span> <span class="nu0">2</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span> <span class="co1">// partial specialization #2</span>
<span class="co1">// fictitious function template for #2 is </span>
<span class="co1">// template&lt;int I&gt;        void f(X&lt;I, I, int&gt;); #B</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    X<span class="sy1">&lt;</span><span class="nu0">2</span>, <span class="nu0">2</span>, <span class="kw4">int</span><span class="sy1">&gt;</span> x<span class="sy4">;</span> <span class="co1">// both #1 and #2 match</span>
<span class="co1">// partial ordering for function templates:</span>
<span class="co1">// #A from #B: void(X&lt;I,J,int&gt;) from void(X&lt;U1, U1, int&gt;): deduction ok</span>
<span class="co1">// #B from #A: void(X&lt;I,I,int&gt;) from void(X&lt;U1, U2, int&gt;): deduction fails</span>
<span class="co1">// #B is more specialized</span>
<span class="co1">// #2 is the specialization that is instantiated</span>
    <a href="../io/cout.html"><span class="kw1753">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> x.<span class="me1">s</span> <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// prints 2</span>
<span class="br0">}</span></pre></div></div>
<h3><span class="mw-headline" id="Members_of_partial_specializations">Members of partial specializations</span></h3>
<p>The template parameter list and the template argument list of a member of a partial specialization must match the parameter list and the argument list of the partial specialization. 
</p><p>Just like with members of primary templates, they only need to be defined if used in the program.
</p><p>Members of partial specializations are not related to the members of the primary template.
</p><p>Explicit (full) specialization of a member of a partial specialization is declared the same way as an explicit specialization of the primary template.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw4">int</span> I<span class="sy1">&gt;</span>  <span class="co1">// primary template</span>
<span class="kw1">struct</span> A <span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// member declaration</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw4">int</span> I<span class="sy1">&gt;</span>
<span class="kw4">void</span> A<span class="sy1">&lt;</span>T,I<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">f</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="br0">}</span> <span class="co1">// primary template member definition</span>
 
<span class="co1">// partial specialization</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> A<span class="sy1">&lt;</span>T,<span class="nu0">2</span><span class="sy1">&gt;</span> <span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw4">void</span> g<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw4">void</span> h<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="co1">// member of partial specialization</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> A<span class="sy1">&lt;</span>T,<span class="nu0">2</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">g</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="br0">}</span>
 
<span class="co1">// explicit (full) specialization</span>
<span class="co1">// of a member of partial specialization</span>
<span class="kw1">template</span><span class="sy1">&lt;&gt;</span>
<span class="kw4">void</span> A<span class="sy1">&lt;</span><span class="kw4">char</span>,<span class="nu0">2</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">h</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
 
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    A<span class="sy1">&lt;</span><span class="kw4">char</span>,<span class="nu0">0</span><span class="sy1">&gt;</span> a0<span class="sy4">;</span>
    A<span class="sy1">&lt;</span><span class="kw4">char</span>,<span class="nu0">2</span><span class="sy1">&gt;</span> a2<span class="sy4">;</span>
    a0.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK, uses primary template’s member definition</span>
    a2.<span class="me1">g</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK, uses partial specialization's member definition</span>
    a2.<span class="me1">h</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK, uses fully-specialized definition of</span>
            <span class="co1">// the member of a partial specialization</span>
    a2.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: no definition of f() in the partial</span>
            <span class="co1">// specialization A&lt;T,2&gt; (the primary template is not used)</span>
<span class="br0">}</span></pre></div></div>
<p>If a class template is a member of another class template, and it has partial specializations, these specializations are members of the enclosing class template. If the enclosing template is instantiated, the declarations of each member partial specialization is instantiated as well (the same way declarations, but not definitions, of all other members of a template are instantiated)
</p><p>If the primary member template is explicitly (fully) specialized for a given (implicit) specialization of the enclosing class template, the partial specializations of the member
template are ignored for this specialization of the enclosing class template.
</p><p>If a partial specialization of the member template is explicitly specialized for a given (implicit) specialization of the enclosing class template, the primary member template and its other partial specializations are still considered for this specialization
of the enclosing class template.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw1">struct</span> A <span class="br0">{</span> <span class="co1">// enclosing class template</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T2<span class="sy1">&gt;</span>
  <span class="kw1">struct</span> B <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// primary member template</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T2<span class="sy1">&gt;</span>
  <span class="kw1">struct</span> B<span class="sy1">&lt;</span>T2<span class="sy2">*</span><span class="sy1">&gt;</span> <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// partial specialization of member template</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw1">template</span><span class="sy1">&lt;&gt;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T2<span class="sy1">&gt;</span>
<span class="kw1">struct</span> A<span class="sy1">&lt;</span><span class="kw4">short</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">B</span> <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// full specialization of primary member template</span>
                       <span class="co1">// (will ignore the partial)</span>
 
A<span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">B</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy2">*</span><span class="sy1">&gt;</span> abcip<span class="sy4">;</span> <span class="co1">// uses partial specialization T2=int</span>
A<span class="sy1">&lt;</span><span class="kw4">short</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">B</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy2">*</span><span class="sy1">&gt;</span> absip<span class="sy4">;</span> <span class="co1">// uses full specialization of the primary (ignores partial)</span>
A<span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">B</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> abci<span class="sy4">;</span> <span class="co1">// uses primary</span></pre></div></div>
<p><br>
</p>
<h3><span class="mw-headline" id="Defect_reports">Defect reports</span></h3>
<p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.
</p>
<table class="dsctable" style="font-size:0.8em">
<tr>
<th> DR
</th>
<th> Applied to
</th>
<th> Behavior as published
</th>
<th> Correct behavior
</th></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1315">CWG 1315</a>
</td>
<td> C++14
</td>
<td> template parameter could not be used in non-type arg expressions other than id-expresisons
</td>
<td> expressions ok as long as deducible
</td></tr></table>

<!-- 
NewPP limit report
Preprocessor visited node count: 1058/1000000
Preprocessor generated node count: 4296/1000000
Post‐expand include size: 34213/2097152 bytes
Template argument size: 9908/2097152 bytes
Highest expansion depth: 15/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:12828-0!*!0!!en!*!* and timestamp 20170331201323 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="http://en.cppreference.com/mwiki/index.php?title=cpp/language/partial_specialization&amp;oldid=91942">http://en.cppreference.com/mwiki/index.php?title=cpp/language/partial_specialization&amp;oldid=91942</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks catlinks-allhidden"><div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden category: <ul><li><a href="http://en.cppreference.com/w/Category:Pages_with_unreviewed_CWG_DR_marker" title="Category:Pages with unreviewed CWG DR marker">Pages with unreviewed CWG DR marker</a></li></ul></div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../../../common/skin_scripts.js"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler"], null, true);
}</script>
<script src="../../../common/site_scripts.js"></script>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-2828341-1']);
_gaq.push(['_setDomainName', 'cppreference.com']);
_gaq.push(['_trackPageview']);
</script><!-- Served in 0.051 secs. -->
	</body>
<!-- Cached 20170331201508 -->
</html>